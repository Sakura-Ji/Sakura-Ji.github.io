---
hide:
  - navigation
  - toc
---

# Sakura_JI的知识库

写自己知识库的思维导图是一个很累人但收获颇丰的事情，事情众多，所以有时间就会自己总结，
同时每个知识点的超链接也很难道，但还是希望自己持续总结到位！同时随之对前端的知识了解，
希望自己以后可以写出像Obsidian中的双链,加油少年！

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.15.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.0/dist/index.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const {
    el
  } = markmap.Toolbar.create(mm);
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
          const markmap = getMarkmap();
          window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
        })(() => window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[0,1]},"content":"Sakura-Ji思维大脑","children":[{"type":"heading","depth":1,"payload":{"lines":[2,3]},"content":"编程语言","children":[]},{"type":"heading","depth":1,"payload":{"lines":[4,5]},"content":"Linux系统","children":[{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"Gcc编译器","children":[{"type":"list_item","depth":3,"payload":{"lines":[8,9],"index":1},"content":"1. GCC 编译器的编译流程","children":[{"type":"list_item","depth":4,"payload":{"lines":[9,10],"index":1},"content":"1. 预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[10,11],"index":2},"content":"2. 编译是将经过预编译处理的代码编译成汇编代码，也就是我们常说的程序编译,检查代码规范性、语法错误等，在检查无误后把代码翻译成汇编语言","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[11,12],"index":3},"content":"3. 汇编就是将汇编语言文件编译成二进制目标文件","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[12,13],"index":4},"content":"4. 链接就是将汇编出来的多个二进制目标文件链接在一起，形成最终的可执行文件，链接的时候还会涉及到静态库和动态库等问题","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[13,14],"index":2},"content":"2. 创建静态库","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[14,15],"index":3},"content":"3. 创建动态库","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[15,16],"index":4},"content":"4. GDB调试","children":[{"type":"list_item","depth":4,"payload":{"lines":[16,17]},"content":"启动单步调试: start","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[17,18]},"content":"n: 按步调式 -- 遇到函数不进入函数内部","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[18,19]},"content":"s: 按步调式 -- 遇到函数会进入函数内部","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[19,20]},"content":"finish: -- 结束当前函数，返回到调用点","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[20,21]},"content":"带有主函数传参的gdb调试","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[22,23]},"content":"Makefile","children":[]},{"type":"heading","depth":2,"payload":{"lines":[24,25]},"content":"Linux文件","children":[{"type":"list_item","depth":3,"payload":{"lines":[26,27],"index":1},"content":"1. 非缓存区的IO文件的函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[27,28]},"content":"open()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[28,29]},"content":"close()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[29,30]},"content":"write()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[30,31]},"content":"read()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[31,32]},"content":"lseek()","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[32,33],"index":2},"content":"2. 时间编程函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[33,34]},"content":"opendir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[34,35]},"content":"closedir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[35,36]},"content":"readdir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[36,37]},"content":"mkdir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[37,38]},"content":"rmdir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[38,39]},"content":"getcwd()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[39,40]},"content":"chdir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[40,41]},"content":"chmod()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[41,42]},"content":"rewinddir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[42,43]},"content":"telldir()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[43,44]},"content":"seekdir()","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[45,46]},"content":"Linux进程","children":[{"type":"list_item","depth":3,"payload":{"lines":[47,48]},"content":"进程的定义：是一个程序一次执行的过程，是操作系统动态执行的基本单元","children":[{"type":"list_item","depth":4,"payload":{"lines":[48,49]},"content":"进程的","children":[]}]},{"type":"list_item","depth":3,"payload":{"lines":[49,50]},"content":"进程的状态","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[50,51]},"content":"进程的资源分配","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[51,52]},"content":"进程的特点","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[52,53]},"content":"进程的关系","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[53,54]},"content":"特殊进程","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[54,55]},"content":"进程的函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[55,56]},"content":"getpid()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[56,57]},"content":"getppid()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[57,58]},"content":"fork()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[58,59]},"content":"vfork()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[59,60]},"content":"exit(0)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[60,61]},"content":"_exit(0)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[61,62]},"content":"wait()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[62,63]},"content":"waitpid()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[63,64]},"content":"system()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[64,65]},"content":"glob()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[65,66]},"content":"atexit()","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[66,67]},"content":"exec函数族","children":[{"type":"list_item","depth":5,"payload":{"lines":[67,68]},"content":"execl()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[68,69]},"content":"execv()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[69,70]},"content":"execle()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[70,71]},"content":"execve()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[71,72]},"content":"execlp()","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[72,73]},"content":"execvp()","children":[]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[74,75]},"content":"Linux通信","children":[{"type":"list_item","depth":3,"payload":{"lines":[76,77]},"content":"IPC(Inter-Process Communication)是指不同进程之间进行数据交换和共享信息的机制","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[77,78]},"content":"IPC的系统命令","children":[]},{"type":"list_item","depth":3,"payload":{"lines":[78,79]},"content":"IPC的通信方式","children":[{"type":"list_item","depth":4,"payload":{"lines":[79,80]},"content":"信号(signal)","children":[{"type":"list_item","depth":5,"payload":{"lines":[80,81]},"content":"系统信号的种类：","children":[{"type":"list_item","depth":6,"payload":{"lines":[81,82]},"content":"信号2：SIGINT： Ctrl+C 结束进程","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[82,83]},"content":"信号3：SIGQUIT：Ctrl + \\ 结束进程","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[83,84]},"content":"信号9：SIGKILL：无条件终止进程的信号。使用SIGKILL信号将无法捕获或忽略，进程会立即被终止。(不能被改造)","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[84,85]},"content":"信号10、12:用户预留的信号","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[85,86]},"content":"信号14：SIGALRM：闹钟信号，用于定时","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[86,87]},"content":"信号17：SIGCHLD：只要子进程状态发生变化，父进程就能够接收到17号信号","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[87,88]},"content":"信号19：SIGSTOP：暂停信号","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[88,89]},"content":"信号18:SIGCONT 是继续进程","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[89,90]},"content":"信号20：SIGTSTP：暂停运行","children":[]}]},{"type":"list_item","depth":5,"payload":{"lines":[90,91]},"content":"信号的函数","children":[{"type":"list_item","depth":6,"payload":{"lines":[91,92]},"content":"kill()","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[92,93]},"content":"raise()","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[93,94]},"content":"alarm()","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[94,95]},"content":"pause()","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[95,96]},"content":"signal()","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[96,97]},"content":"无名管道(pipe)","children":[{"type":"list_item","depth":5,"payload":{"lines":[97,98]},"content":"无名管道可以方便地实现父子进程之间的通信","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[98,99]},"content":"无名管道的函数","children":[{"type":"list_item","depth":6,"payload":{"lines":[99,100]},"content":"pipe()","children":[]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[100,101]},"content":"有名管道(Name Pipe)","children":[{"type":"list_item","depth":5,"payload":{"lines":[101,102]},"content":"可以通过文件系统路径进行访问，允许不相关的进程之间进行通信","children":[{"type":"list_item","depth":6,"payload":{"lines":[102,103]},"content":"有名管道的函数","children":[{"type":"list_item","depth":7,"payload":{"lines":[103,104]},"content":"mkfifo()","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[104,105]},"content":"access()","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[105,106]},"content":"unlink()","children":[]}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[106,107]},"content":"共享内存(Shared Memory)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[107,108]},"content":"信号量集(Semaphore)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[108,109]},"content":"信号队列(Message Queue)","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[109,110]},"content":"套接字(Socket)","children":[{"type":"list_item","depth":5,"payload":{"lines":[110,111]},"content":"套接字函数","children":[{"type":"list_item","depth":6,"payload":{"lines":[111,112]},"content":"socket():创建一个套接字，并返回一个文件描述符。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[112,113]},"content":"bind(): 将套接字与特定的地址和端口绑定。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[113,114]},"content":"listen(): 将一个流套接字转换为被动监听模式，等待连接请求。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[114,115]},"content":"accept(): 接受连接请求，并返回一个新的套接字文件描述符，用于与客户端进行通信。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[115,116]},"content":"connect(): 建立与服务器的连接。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[116,117]},"content":"send(): 发送数据到套接字。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[117,118]},"content":"recv(): 从套接字接收数据。","children":[]},{"type":"list_item","depth":6,"payload":{"lines":[118,119]},"content":"close(): 关闭套接字。","children":[]}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[120,121]},"content":"Linux线程","children":[{"type":"list_item","depth":3,"payload":{"lines":[122,123]},"content":"线程的函数","children":[{"type":"list_item","depth":4,"payload":{"lines":[123,124]},"content":"pthread_create() 用于创建一个新的线程的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[124,125]},"content":"pthread_join() 用于等待指定的线程结束，并获取其返回值(如果有)的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[125,126]},"content":"pthread_exit() 用于终止当前线程，并可选择传递一个线程的退出状态的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[126,127]},"content":"pthread_self() 用于获取调用它的线程的线程ID(Thread ID)的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[127,128]},"content":"pthread_cancel() 用于取消指定的线程的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[128,129]},"content":"pthread_cleanup_push() 和 pthread_cleanup_pop() 用于在线程执行过程中注册清理函数的函数","children":[]},{"type":"list_item","depth":4,"payload":{"lines":[129,130]},"content":"pthread_kill() 用于向指定的线程发送信号的函数(同进程)","children":[]}]}]},{"type":"heading","depth":2,"payload":{"lines":[131,132]},"content":"Linux网络","children":[{"type":"heading","depth":3,"payload":{"lines":[133,134]},"content":"通信协议","children":[{"type":"list_item","depth":4,"payload":{"lines":[135,136],"index":1},"content":"1. TCP（Transmission Control Protocol 传输控制协议）","children":[{"type":"list_item","depth":5,"payload":{"lines":[136,137]},"content":"是一种面向连接的、可靠的、基于字节流的传输层通信协议，利用套接字进行通信。","children":[]},{"type":"list_item","depth":5,"payload":{"lines":[137,138]},"content":"TCP 编程的 C/S 架构","children":[{"type":"list_item","depth":6,"payload":{"lines":[138,139]},"content":"客户端","children":[{"type":"list_item","depth":7,"payload":{"lines":[139,140],"index":1},"content":"1. <a href=\"../../LinuxSystem/Communication#Socket\">socket()</a>","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[140,141],"index":2},"content":"2. 设置要登录的服务器地址IP和端口号Port","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[141,142],"index":3},"content":"3. connect()向服务器端请求建立连接","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[142,143],"index":4},"content":"4. send()向服务器发送消息--参数中的socket是客户端自己创建的","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[143,144],"index":5},"content":"5. recv()接收服务器消息--参数中的socket是客户端自己创建的","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[144,145],"index":6},"content":"6. close()关闭客户端创建的套接字","children":[]}]},{"type":"list_item","depth":6,"payload":{"lines":[145,146]},"content":"服务器","children":[{"type":"list_item","depth":7,"payload":{"lines":[146,147],"index":1},"content":"1. socket()","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[147,148],"index":2},"content":"2. 设置服务器地址IP和端口号Port","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[148,149],"index":3},"content":"3. bind()将套接字与特定的地址和端口绑定","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[149,150],"index":4},"content":"4. listen()设置服务器在同一时刻最多允许多少个客户端连接","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[150,151],"index":5},"content":"5. accept()等待客户端连接并创建新的套接字--通信套接字","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[151,152],"index":6},"content":"6. recv()接收客户端发送的消息--参数中的socket是accept创建的通信套接字","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[152,153],"index":7},"content":"7. send()向客户端发送消息--参数中的socket是accept创建的通信套接字","children":[]},{"type":"list_item","depth":7,"payload":{"lines":[153,154],"index":8},"content":"8. close()关闭服务器创建的套接字和accept创建的新的用来通信的套接字+","children":[]}]}]}]},{"type":"list_item","depth":4,"payload":{"lines":[154,155],"index":2},"content":"2. UDP（User Datagram Protocol）无连接的网络通信协议","children":[]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[156,157]},"content":"嵌入式编程","children":[]},{"type":"heading","depth":1,"payload":{"lines":[158,159]},"content":"GodTool","children":[]}]},{})</script>
</body>
</html>
