# IPC通信

## IPC介绍

在Linux系统中，进程间通信（IPC，Inter-Process Communication）是指不同进程之间进行数据交换和共享信息的机制。
进程间通信对于实现协作和协调多个进程之间的工作至关重要。

**为什么进程间需要通信的一些常见原因:**

1. 数据共享: 不同进程可能需要共享数据，以便彼此之间进行信息传递、协作和同步操作。
2. 任务分解: 一个复杂的任务可能需要分解为多个进程来并行执行，进程间通信可以在不同的进程之间传递任务和结果数据。
3. 资源共享: 不同进程可能需要共享系统资源，如文件、网络连接、设备或内存等。
4. 进程控制: 一个进程可能需要控制其他进程的行为，例如启动、停止、暂停或发送信号给其他进程。

**常见的IPC通信方式包括:**

> 不同的IPC通信方式适用于不同的场景和需求,选择适合的方式取决于具体的应用需求和限制条件

1. [信号(signal)](#signal): 信号是Linux系统中用于通知进程发生某个事件的机制，进程可以通过捕捉和处理信号来与其他进程进行通信。
2. [管道(Pipe)](#Pipe): 管道是一种半双工的通信方式，它通过创建一个内核缓冲区，使得一个进程的输出直接变为另一个进程的输入。通常用于父子进程之间或者具有亲缘关系的进程之间的通信。
3. [有名管道(Named Pipe)](#Named): 命名管道允许无亲缘关系的进程之间进行通信，它是一种先进先出（FIFO）的特殊文件。进程可以通过打开这个文件进行读写操作。
4. [共享内存(Shared Memory)](#Shared): 共享内存允许多个进程共享同一块内存区域，它是一种高效的IPC方式，因为数据无需复制就可以在进程之间传递。但需要注意的是，使用共享内存时需要借助其他机制如信号量或互斥锁来确保数据的同步和互斥访问。
5. [信号量集(Semaphore)](#Semaphore): 信号量是一种计数器，用于多个进程之间的同步和互斥访问共享资源。它可以用来控制对共享内存的访问以及进程之间的顺序执行。
6. [消息队列(Message Queue)](#Message): 消息队列是一种存储在内核中的消息链表，进程可以通过往队列中写入消息和从队列中读取消息来进行通信。消息队列可以实现按照特定的优先级来处理消息。
7. 套接字(Socket): 套接字是一种用于在网络中进行进程间通信的通信机制，它可以用于不同主机上的进程相互通信，实现分布式应用程序之间的交互。

### 系统命令

使用命令查看系统中所有的IPC通信:

命令:`ipcs`

![ipcs](https://raw.githubusercontent.com/Sakura-Ji/MapDepot/main/Mkdocs/ipcs.png)

常用的`ipcs`命令选项包括：

* `-a`：显示系统中所有的IPC对象。
* `-m`：仅显示共享内存对象的信息。
* `-q`：仅显示消息队列对象的信息。
* `-s`：仅显示信号量对象的信息。
* `-t`：以可读的格式显示时间戳。
* `-u`：显示当前用户创建的IPC对象。

删除:

* `ipcrm -q id` 删除消息队列
* `ipcrm -m id` 删除共享内存
* `ipcrm -s id` 删除信号量集

### IPC键值

在进程间通信（IPC）中，键值（key）是一个用于标识和访问IPC对象的唯一值。键值充当了IPC对象的唯一索引，使得不同的进程可以通过键值来找到和访问相同的IPC对象。

在不同的IPC机制中，键值的定义和生成方法可能会略有差异。下面是一些常见的IPC机制以及对应的键值生成方式：

1. 信号（Signal）：
    * 信号没有显式的键值，而是使用信号编号来识别和处理。

2. 共享内存（Shared Memory）：
    * 使用[ftok](#ftok)函数将一个文件路径和项目标识符转换为键值。例如：`key_t key = ftok("/path/to/file", 'P');`
    * 文件路径通常是一个存在的文件，用于在不同的进程之间共享键值。

3. 消息队列（Message Queue）：
    * 使用一个整数作为键值，可以手动指定或根据应用程序的需求进行生成。

4. 信号量（Semaphore）：
    * 使用一个整数作为键值，可以手动指定或根据应用程序的需求进行生成。

5. 套接字（Socket）：
    * 使用网络地址（IP地址和端口号）作为连接套接字的键值。

注意，键值的选择要遵循一些准则:

* 键值在所有进程中必须是唯一的。
* 不同进程之间要使用相同的键值来访问相同的IPC对象。
* 键值应与应用程序的需求和逻辑相匹配，以确保正确的对象关联。

在使用IPC机制时，进程需要使用相同的键值才能访问和操作相同的IPC对象。
因此，确保在不同进程之间共享正确的键值是非常重要的。

### IPC函数 {#ftok}

1. 键值是一个整数，通常使用`ftok`函数将一个唯一的文件和一个项目标识符（project identifier）转换为键值
2. 用于创建或打开共享内存段的函数 `shmget`

!!! example "函数原型"

    === "ftok"
        
        注意:不同进程要访问同一个共享内存区域，需要使用相同的键值。
        ```c

        所需头文件:
        #include <sys/types.h>
        #include <sys/ipc.h>
        函数原型:key_t ftok(const char *pathname,int proj_id);
        参数:
        pathname:路径，任意的pathname就是你指定的文件名(该文件必须是存在而且可以访问的)
        proj_id:是子序号，虽然为int，但是只有8个比特被使用(0-255)
        返回值:当成功执行的时候，一个key_t值将会被返回，否则 -1 被返回
        
        ```

        ```c title="举例"

        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <stdio.h>
        
        int main()
        {
          key_t a = ftok("/home", 99);//生成键值
          printf("1.c中的a=%d\n",a);//1.c与2.c不同处只有printf这里
          return 0;
        }

        ```
        ![shared-memory-key](https://raw.githubusercontent.com/Sakura-Ji/MapDepot/main/Mkdocs/shared-memory-key.png)

    === "shmget"

        ```c

        所需头文件:
        #include <sys/ipc.h>
        #include <sys/shm.h>
        函数原型:
        int shmget(key_t key, size_t size, int shmflg);
        形参:
        * key: 共享内存的键值，通常使用`ftok`函数生成。不同进程要访问同一块共享内存，需要使用相同的键值。
        * size: 共享内存段的大小，以字节为单位。
        * shmflg: 标志位，用于指定创建共享内存的权限和特性。
            示例: IPC_CREAT|0777 如果共享内存已经存在，就只打开，如果不存在，创建并打开
        返回值：成功返回一个int类型的标识符
                失败-1

        ```

## 信号 {#signal}

## 管道 {#Pipe}

## 有名管道 {#Named}

## 共享内存 {#Shared}

### 理论

在IPC通信中，共享内存是一种高效的进程间通信机制。不同进程可以映射同一块共享内存区域到它们各自的地址空间中，从而实现数据的共享和直接访问。

使用共享内存进行进程间通信，通常会经过以下步骤：

1. 创建共享内存：首先，需要调用IPC函数（如`shmget`）创建一个共享内存区域，并指定所需的大小和权限。传递给`shmget`函数的参数包括键值、内存大小和标志等。

2. 连接(映射)共享内存：每个进程都需要调用IPC函数（如`shmat`）来连接到共享内存区域。`shmat`函数返回指向共享内存的指针，进程可以通过该指针进行直接的读写操作。

3. 进行数据交互：一旦进程连接到了共享内存，它们可以直接通过读写共享内存的方式进行数据交换。注意，需要确保进程之间对共享内存的访问同步和互斥，以避免数据的竞争和一致性问题。

4. 分离(解除)共享内存：当进程不再需要共享内存时，需要调用IPC函数（如`shmdt`）来分离共享内存区域。这样，进程就不再拥有对共享内存的访问权限。

5. 删除共享内存（可选）：如果不再需要使用共享内存，可以调用IPC函数（如`shmctl`）删除共享内存区域。这会释放相关的系统资源，并使得其他进程无法连接到该共享内存。

需要注意的是，共享内存作为一种进程间通信机制，存在一些潜在的问题，比如数据一致性、并发访问等。因此，在使用共享内存时要注意合理设计数据结构、使用同步机制（如信号量、互斥锁）来保证数据的正确性和安全性。

共享内存通信虽然高效，但也要谨慎使用。在设计中，除了共享内存，还可以结合其他IPC通信方式，如信号量、管道等，综合考虑选择适合的通信机制以满足具体需求。



## 信号量集 {#Semaphore}

## 消息队列 {#Message}

